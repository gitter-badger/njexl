\chapter{Examples with Interview Questions}\label{examples}

{\LARGE E}xamples should be abundant, and this chapter is massively inspired from \href{http://www.amazon.com/Programming-Pearls-2nd-Edition-Bentley/dp/0201657880}{Programming Pearls}. The idea behind this chapter is many examples that happens practically, 
and how to solve the problems in least possible code, in the best possible way.
Although the whole book is pretty abundant in examples - this chapter has its own advantages.
Some are simply what I explicitly call \href{http://www.urbandictionary.com/define.php?term=intellectual+masturbation}{IM}, 
but that sales in the interviews for the kids. 
I have heavily against many of these as practical interview questions. 
But never the less :

\begin{center}
\emph{If it is ones lot to be cast among fools, one must learn foolishness. }\\
   --Alexandre Dumas, The Count of Monte Cristo
\end{center}

\begin{section}{Assorted Impractical Examples}
This section has almost everything that qualifies as IM. It is good we start with them first,
because IM, for many many Software people is a very pleasurable activity.

\begin{subsection}{A Game of Scramble}
\index{ examples : scramble }
I am sure you guys have know the game of jumbled up words. For example, someone gives you ``Bonrw'' and you need to say : ``Brown'' ! 
Suppose I tell you to write a program to do it.
The simplest solution is this :

\begin{center}
\emph{if we sort the all the words in a dictionary letter by letter and then use that sorted word as a key? Then we can easily solve the problem by sorting on the letters of the word given and then checking if that as key exist in the dictionary, then, find all possible matches !}
\end{center}
\index{ examples : Scramble }
\begin{center}\begin{minipage}{\linewidth}
\begin{lstlisting}[style=JexlStyle]
fi = lines('words.txt')
word_dict = lfold{ 
               // generate char array
               ca = $.toCharArray()  
               // generate a key by sorting and concatenating 
               key = str(sorta(ca),'') 
               // add the word to the { key : list of words } 
               if ( not ( key @ _$_ ) ) {  _$_[key] = list()  }
               _$_[key] += $ 
               _$_ // return the partial 
             }(fi, dict() )
// now a jumbled up word exists ?
key = str( sorta( jumbled_word.toCharArray() ), '')
matches = word_dict[key]
write(matches)
\end{lstlisting}  
\end{minipage}\end{center}
\end{subsection}

\begin{subsection}{Find Anagrams of a String}
\index{ examples : anagrams }
The problem is, suppose someone gave you a string : ``waseem'' say. The idea is to list all possible words
with the letters in it. The letters may or may not have meaning, but that is ok. How to solve this problem?

The easy method is to generate permutation of all the letters, and check if it occurred before.
Thus, given $word$ is the string :
\begin{center}\begin{minipage}{\linewidth}
\begin{lstlisting}[style=JexlStyle]
// create a set of words 
words = set()
// get the sorted version in an array 
letters = sorta ( word.toCharArray() )
// generate the args for permutations 
args = array{ letters }( [0 : #|letters|] )
perms = join{ continue ( $ != letters )
              v = str($,'') ; continue( v @ words )
              // add the permutation to the words
              words += v ; false // no need to store anything
       }(__args__ = args )
// now words has all the anagrams 
\end{lstlisting}  
\end{minipage}\end{center}
and this solves the problem. Notice that many advanced concepts are being used in the solution.
\end{subsection}

\begin{subsection}{Sublist Sum Problem}
\index{ examples : sublist sum problem }
Given a list of integers, and a value sum, determine if there is a sublist of the given list with sum equal to given sum.
There is a dynamic programming solution - which is left for the reader to figure out. 
Our solution would be minimalist. Observe that the solution is finding all possible combinations of the list, 
and check where the sum comes up. So, we notice that the previous anagram problem is the building block of this problem too!
So, suppose the list of integers are stored in $li$ :
\begin{center}\begin{minipage}{\linewidth}
\begin{lstlisting}[style=JexlStyle]
// create a set for solutions 
solutions = set()
// get the sorted version of the list 
li = sorta ( li )
// generate the args for permutations 
args = array{ li }( [0 : #|li|] )
perms = join{ continue ( $ != li )
              // we need the sum 
              sm = sqlmath($)
              // sm[2] holds the sum 
              continue( sm[2] != sum ) 
              $ = sorta($) // we need combinations 
              v = str($) ; continue( v @ solutions )
              // add the combination to the solutions
              solutions += v ; false // store nothing
       }(__args__ = args )
// now solutions has all the solutions to the problem 
\end{lstlisting}  
\end{minipage}\end{center}
\end{subsection}

\begin{subsection}{Sublist Predicate Problem}
\index{ examples : sublist predicate problem }
Observe that, the most generic way to represent all of the above problems is by introducing 
a predicate $P(\$)$ , and stating the problem as such :
\begin{center}\emph{
Given a list , and a predicate $P(\$)$, determine if there is a sublist of the given list where $P(\$)$ is True.
}
\end{center}
Thus, the generic solution becomes :
\begin{center}\begin{minipage}{\linewidth}
\begin{lstlisting}[style=JexlStyle]
// create a set for solutions 
solutions = set()
// get the sorted version of the list 
li = sorta ( li )
// generate the args for permutations 
args = array{ li }( [0 : #|li|] )
perms = join{ continue ( $ != li )
              continue( not P($) ) 
              $ = sorta($) // we need combinations 
              v = str($,'#') ; continue( v @ solutions )
              // add the combination to the solutions
              solutions += v ; false // store nothing
       }(__args__ = args )
// now solutions has all the solutions to the problem 
\end{lstlisting}  
\end{minipage}\end{center}

\end{subsection}

\begin{subsection}{List Closeness Problem}
\index{ examples : list closeness }
Suppose there are points in a \href{https://en.wikipedia.org/wiki/Metric\_space}{metric space},
collected in a list. There are two such lists, and we need to check if these lists are sufficiently close to 
one another or not. Formally, given the \href{https://en.wikipedia.org/wiki/Distance\#General\_metric}{distance function} $d(,)$,
and two collections ( of same size $N$ ) $A,B$, they are close iff there exists permutations of $A,B$ defined as $\pi_m(A)$ and $\pi_n(B)$
such that :
$$
\forall i \in \{ 0 , ... , N - 1 \} \; ; \; d( \pi_m(A[i]) , \pi_n(B[i]) ) < \epsilon  
$$   
where $m$ and $n$ represents the \href{http://mathworld.wolfram.com/PermutationIndex.html}{Permutation Index},
and $\epsilon$ is the \href{https://en.wikipedia.org/wiki/Closeness\_(mathematics)}{closeness}.
In simple english, given two list of numbers of the same size, and a closeness number $\epsilon$, this looks:
  
$$
\forall i \in \{ 0 , ... , N - 1 \} \; ; \;  |\pi_m(A[i]) - \pi_n(B[i]) | < \epsilon  
$$   

This is not a hard problem, but is formulated as such. To solve it, observe that given the distance metric, 
one can calculate the distance of all the points from a base point, in case of numbers, that would be 0. 
That would let us create an \href{https://en.wikipedia.org/wiki/Total\_order}{order relation} over the numbers.
Thus, we can order the numbers in the ascending order, and then $i$'th element of $A$ must be close to $i$'th element of $B$.
That is, suppose $A_s,B_s$ are the sorted versions of $A,B$, then :

$$
\forall i \in \{ 0 , ... , N - 1 \} \; ; \;  | A_s[i] - B_s[i] | < \epsilon  
$$   
and thus, the nJexl solution is :
 
\begin{center}\begin{minipage}{\linewidth}
\begin{lstlisting}[style=JexlStyle]
AS = sorta(A)
BS = sorta(B)
e = 0.01 // say?
s = #|AS| // the size 
close = ( index{ #|AS[$] - BS[$]| > e  }([0:s]) < 0 )
\end{lstlisting}  
\end{minipage}\end{center}
\end{subsection}

\begin{subsection}{Shuffling Problem}
\index{ examples : ex seating problem }
The problem statement is :

\emph{Given a string e.g. ``ABCDAABCD''. Shuffle the string so that no two similar letters together. 
E.g. AABC can be shuffled as ABAC.}

So, how to solve this? As always, we formalise the problem. 
First we find that how many same alphabets are present, and make a group.
Then, we go round robin over all the groups and exhaust the groups.
When there would be no solutions? Clearly using the \href{https://en.wikipedia.org/wiki/Pigeonhole\_principle}{Pigeonhole Principle} 
one can say, when one group would have more characters than the rest of the characters plus 1.
For example, there can not be any solution for the string ``AAA'' : trivial, and ``AAAB''.

\begin{center}\begin{minipage}{\linewidth}
\begin{lstlisting}[style=JexlStyle]
word = 'ABCDAABCD'
m = mset(word.toCharArray() )
#(min,Max) = minmax{ size($[0].value) < size($[1].value) }(m)
solvable = ( #|word| + 1 < 2 * #|Max.value| )
not ( solvable ) or bye('sorry, no solution exists!')
keys = list(m.keySet())
shuffle(keys)
len = #|keys|
i = -1 
result = lfold{ 
      i+= 1 
      key = keys[i % len]  
     _$_ + m[key][0]           
}([0:#|word|],'')
write(result)
\end{lstlisting}  
\end{minipage}\end{center}
Observe the use of the $bye()$ function. When it is called, it simply returns
from the calling function, with the string as return value.
\index{bye()}
Wonder where it can be practically applied? I can think of one.
Suppose we are going to go at a diner where girls and boys came. 
Now, there would be ( if the soap operas are slightly true ) boys and girls who were
involved with one another. Thus a relationship existed is defined by $_xEX_y$ 
which means $x,y$ were emotionally attached. 
Now, an extended relationship can be found, extending $R$, so that $_xEX_y$ and $_yEX_z$ 
implies $_xEX_z$ where $N$ stands for do not talk. Clearly, $N$ is a set generate by $EX$.
Clearly none in the same $N$ set wants to talk to one another, and thus
do not want to seat side by side. That brings the problem, and 
now you see, how emotional stuff can generate a nice computer algorithm, 
that Microsoft asks in Interviews.

\end{subsection}

\begin{subsection}{Reverse Words in a Sentence}
\index{examples : reverse words }
Suppose a sentence reads : ``\emph{This is an utter waste of time}'', 
we should reverse the order of the words. 

\begin{center}\begin{minipage}{\linewidth}
\begin{lstlisting}[style=JexlStyle]
line = 'This is an utter waste of time'
words = tokens{ $ }( line, '\S+')
words = words ** -1
result = str(words, ' ') 
\end{lstlisting}  
\end{minipage}\end{center}

We can reduce it further :

\begin{center}\begin{minipage}{\linewidth}
\begin{lstlisting}[style=JexlStyle]
line = 'This is an utter waste of time'
result = ''
tokens{ result += ' ' + $ ; continue }( line, '\S+')
result = result.substring(1)
\end{lstlisting}  
\end{minipage}\end{center}

\end{subsection}

\begin{subsection}{Recursive Range Sum}
\index{examples : recursive range sum}
Write a recursive function: \emph{ sum(x,max ) } 
that calculates the sum of the numbers from x to max (inclusive). 
For example, $sum(4,7)$ would compute $4 + 5 + 6 + 7$ and return the value $22$. 
The function must be recursive so you are not allowed to use any conventional loop constructs.

\begin{center}\begin{minipage}{\linewidth}
\begin{lstlisting}[style=JexlStyle]
def sum(x,max){
   dif = max - x
   x*(diff + 1) + diff*(diff+1)/2  
}
\end{lstlisting}  
\end{minipage}\end{center}
This function uses integer arithmetic, and hence is recursive.
Obviously people do not know that add and subtract are actually recursion.
So, for ordinary people, lets solve it in ordinary way :

\begin{center}\begin{minipage}{\linewidth}
\begin{lstlisting}[style=JexlStyle]
def sum(x,max){
   if ( max == x ) return x
   return ( max + sum(x, max - 1 ) )
}
x = int(__args__[1])
max = int(__args__[2])
write(sum(x,max))
\end{lstlisting}  
\end{minipage}\end{center}

\end{subsection}

\begin{subsection}{String from Signed Integer}
\index{examples : string from signed integer }
With input as a integer, write an algorithm to convert that to string 
without using any built in functions. It may be a signed number. 
This is obviously by done by simply calling the \emph{str()}, 
but people loves IM, so :

\begin{center}\begin{minipage}{\linewidth}
\begin{lstlisting}[style=JexlStyle]
def to_str(i){
   if ( i == 0 ) return "0"
   sign = (i < 0 )?'-':''
   i = ( i> 0 )?i:-i
   s = '' 
   for ( ; i > 0 ; i = i/10 ){
     s =  str( i % 10) + s 
   } 
   sign + s    
}
write ( to_str( int(__args__[1] ) ))
\end{lstlisting}  
\end{minipage}\end{center}
\end{subsection}

\begin{subsection}{Permutation Graph}
\index{examples : permutation graph}
Given an integer "n" and pair of "I" swapping indices, 
generate the largest number. Swapping indices can be reused any number times. 

\begin{lstlisting}[style=all]
n : 1243 
Indices: 
(0,3) 
(2,3) 
Answer: 
3421, 3214, 4213, 4231,...
The result is 4231 which is the largest.
\end{lstlisting}  

The problem is that of \href{https://en.wikipedia.org/wiki/Permutation\_graph}{Permutation Graph}.
Observe, then, the rules lets you generate nodes from the starting node.
Also observe that the size of the graph generated by the rules is finite, 
the graph generated is strictly a 
\href{https://en.wikipedia.org/wiki/Glossary_of_graph_theory\#subgraph}{subgraph} 
of the overall permutation graph, 
which is finite by definition. A subset of a finite set is finite. 

So, how to generate the graph? Obviously we need to apply the rules again and again.
But there is a chance of a \href{https://en.wikipedia.org/wiki/Cycle\_(graph_theory)}{cycle}.

The problem here, is a very well known problem: 
\href{https://en.wikipedia.org/wiki/Graph\_traversal\#Graph\_exploration}{Graph Exploration}.
Given this problem came from Facebook is quite apt. So, how do we solve it?

\begin{enumerate}
\item{Keep a dictionary of traversed nodes, or say integers : nodes := \{ node : traversed ? false \}  }
\item{Initialise nodes to starting seed (1243). }
\item{Pick one item from the node set, which is not traversed, and apply both the rules. }
\item{If the results generates new nodes, not already in nodes, then add them to nodes }
\item{If traversal yield old nodes, mark the node as traversed : true }
\item{check if there is any nodes left to pick and traverse}
\item{The exploration is done, now go over all the nodes and check which one is the largest. }
\end{enumerate}

And here is the nJexl code :
\index{operator : division on dictionary }
\begin{center}\begin{minipage}{\linewidth}
\begin{lstlisting}[style=JexlStyle]
nodes = { 1243 : false }
rules = [ [0,3] ,[2,3] ] 
/* generate the permutation */
def get_node(cur,rule){
   c_array = str(cur).toCharArray()
   t = c_array[rule.0]
   c_array[rule.0] = c_array[rule.1]
   c_array[rule.1] = t 
   int ( str(c_array,'')) 
}
/* Explore the Graph */
while (true){
   /* observe the division over a dictionary 
      This generates a set of keys where 
      value is the right operand */
   not_traversed = nodes / false 
   break(empty(not_traversed)) 
   // mark as true 
   nodes[ not_traversed[0] ] = true
   // get the current node 
   cur = not_traversed[0] 
   lfold {
          // generate the next node 
          nn = get_node( cur, $ )
          // in case it exists, continue 
          continue(nn @ nodes )
          // add to the dictionary for nodes 
          nodes[nn] = false 
    }(rules)
}
// generate the min, max 
#(m,M) = minmax{ $[0].key <  $[1].key }(nodes)
write(M)
\end{lstlisting}  
\end{minipage}\end{center}
\end{subsection}

\begin{subsection}{Find Perfect Squares}
\index{examples : find perfect squares}
Find the list of perfect squares between two given numbers.
So, how do we solve it? We go back to formalism : the perfect squares are:
$$
s = \{ x | \exists n \in \mathbb{N} \; s.t.\; x = n^2  \; and \;  b \le x \le e  \} 
$$
Thus, to solve it :
\begin{center}\begin{minipage}{\linewidth}
\begin{lstlisting}[style=JexlStyle]
begin = Z( b ** 0.5 )
end = Z( e ** 0.5 ) + 1 
ps = select{ x = $*$ // generate the square 
       where ( x >= b and x <= e ){
           $ = x // store back the value    
       } 
    }( [begin : end ])
\end{lstlisting}  
\end{minipage}\end{center}
\end{subsection}

\end{section}


\begin{section}{Assorted Practical Examples}
This section contains examples which would probably never be asked in any interviews,
if anyone asks the in an interview, please join that firm immediately.

\begin{subsection}{Generic Result Comparison}
\index{examples : generic result comparison}
Most of the time, it is of importance that we compare results coming from an 
older and a newer system. Both are to be somehow equivalent.
Obviously these results are list of complex objects, which differs with the versions.
Thus, the objects which comprise of the old list $ol$ would be slightly different 
than that of the new list $nl$. 

Thus, the only way to handle these sort of thing would be using the 
\href{https://en.wikipedia.org/wiki/Projection\_(relational\_algebra)}{projection operator}.
That is, isolate the set of fields which are equivalent , that would be a list of tuple :
$C_i = ( _OC_i,_NC_i )$ where $_OC_i$ is the old field, while $_NC_i$ is the new field.
That is really not the most generic way, but let's assume it is.
Now, it boils down to doing the projection on these :
$$
t_o = \Pi_{ _OC }(O_o) 
$$ 
and
$$
t_n = \Pi_{ _NC }(O_n)
$$ 
and now, there are lists of it. Thus, now, these two list should be equal.
Hence, in nJexl, here is the code one would write :

\begin{center}\begin{minipage}{\linewidth}
\begin{lstlisting}[style=JexlStyle]
// old tuple list , generated by projecting old columns 
otl = list{ o = $ ; lfold{ _$_ + '#' + o[$]}(OC, '')}(ol)
// new tuple list , generated by projecting new columns 
ntl = list{ o = $ ; lfold{ _$_ + '#' + o[$]}(NC, '')}(nl)
// now compare 2 list of strings!
matches = ( otl == ntl )  
\end{lstlisting}  
\end{minipage}\end{center}
\end{subsection}

\begin{subsection}{Verifying Filter Results}
\index{examples : verifying filter results}
Sometimes people tend to write imperative code to apply filter on search results.
That is, given the result is a list of objects, all the objects would be yielding true
while applying predicate $P()$. Thus, formally, a filtered collection $F$ over a collection $C$ is :
$$
\forall x \in F \; ; \; P(x)  = True 
$$
and this $F \subseteq C$. The question is how to test for filtering?
Given we already have a predicate $P()$ defined :
 
\begin{center}\begin{minipage}{\linewidth}
\begin{lstlisting}[style=JexlStyle]
filtered = ( index{ not P($) }(F) < 0 ) and F <= C  
\end{lstlisting}  
\end{minipage}\end{center}
But this has a problem. The solution loops over both $F$ and $C$. 
Will there be a way to reduce the looping? Given $C$ is a set, it is easy :

\begin{center}\begin{minipage}{\linewidth}
\begin{lstlisting}[style=JexlStyle]
filtered = ( index{ not P($) and not $ @ C }(F) < 0 )
\end{lstlisting}  
\end{minipage}\end{center}

But what if, given $C$ is not a set, but a list? That can be solved by
invocation of multi set, or $mset()$ \index{mset()} :
\begin{center}\begin{minipage}{\linewidth}
\begin{lstlisting}[style=JexlStyle]
l = [1,2,2,3,4,4,4]
ml = mset(l)
/* ml := { 1 : [1] , 2:[2,2] , 3:[1], 4:[4,4,4] } */
\end{lstlisting}  
\end{minipage}\end{center}
With this, the new verification declaration would be :

\begin{center}\begin{minipage}{\linewidth}
\begin{lstlisting}[style=JexlStyle]
m = mset(C)
// replace with counts 
mc = dict{ [ $.key, #|$.value| ] }(m)
filtered = index{ 
               continue( $ @ mc and P($) ){  
                      mc[$]-=1 ; mc[$] < 0  }
               // control came here, failed         
               true    
            }(F) < 0 
\end{lstlisting}  
\end{minipage}\end{center}
 
\end{subsection}

\end{section}

