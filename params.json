{
  "name": "Njexl",
  "tagline": "A  language based on apache jexl for software testing & Business Programming needs",
  "body": "# nJexl\r\n\r\nA  language based on [apache JEXL](http://commons.apache.org/proper/commons-jexl/) for Business Programming as well as software testing needs.\r\nThis is a result of my experience and experiment with software development for over a decade.\r\nA wise man once told me  \"Never build a fool proof software. When you complete building one 1.0 version, \r\nthe fool will release foolishness 2.0.\". He was 15 years in Industry then, and is an MBA from IIM-A.\r\nMy team mates in Microsoft judged him the smartest and wisest man in the team. Thus, it is our opinion.\r\nOur personal opinion, not of my company, not of my friends, family or foes. Entirely mine.\r\nIt also is a software testing framework, and for multibrowser/multisystem testing\r\nthis project use and reccomends [BrowserStack](www.browserstack.com/) for the web testing part.\r\nI belive that resources in the internet should remain open, and free of cost.\r\nI believe in the [Mozilla Manifesto](https://www.mozilla.org/en-US/about/manifesto/).\r\n\r\nFor including this programmatically into your JVM code see the examples [here](http://commons.apache.org/proper/commons-jexl/reference/examples.html).\r\n\r\nThe improved language manual can be found ( always updated ) in the wiki. As github does not have search manual options,\r\nsuggested way to access manual is to search google with \"njexl topic_name wiki\" :)\r\nAlso a full [pdf manual](https://github.com/nmondal/njexl/blob/master/doc/pdfs/nJexl.pdf) is maintained which is always updated. \r\n\r\n## Summary\r\n\r\nSoftware Testing & Automation has become messy, stagnant  trivial *record and playback*.\r\nYes, anyone should be able to automate, that does not really mean *anyone can automate*.\r\nThat actually means : *a great automation engineer can come from anywhere*. \r\n\r\nThese so called *automation tools* promise too much, deliver too little. \r\nThese promises are faulty never the less, because the aspect they tackled is the driving aspect of the UI. \r\nNONE, and I repeat, *NO Tool designed ever bothers about the VALIDATION aspect of the software testing*.\r\n\r\nNJEXL is a small step in fixing this. A small step by one random *lone ranger*.\r\nPerhaps this going to be a big step in the direction of *THINK VALIDATION* philosophy in software testing,\r\nwhich none of the *frameworks*  exhibit now.\r\n\r\n## Motivation\r\n\r\nDeclarative/functional programming style is easy to be implemented as a testing validation philosophy.  \r\nHowever, the so called *TEST FRAMEWORKS* only give you asserts. \r\nThose asserts gets used to compare objects, nulls, not nulls. If they designed it real smart, really smart, perhaps \r\nthey would compare list even. That is a matter of some *serious concern*. \r\nReal software is not about matching nulls, and equaling objects. Yes, 99% of the so called software people believe that.\r\nBut no, what you are doing is a real *tiny winy* part of *Unit Tests*.\r\n*Real Testing* does not happen using asserts equaling objects.\r\nReal software testing is validating conditions and data. Testing is not easy. Testing is not trivial.\r\nIn short testing is what computer theorists call predicate operations ( predicate logic ).\r\n\r\n## Predicate Formulation of Truth\r\n\r\nThe formulation is : *Is the STATEMENT \"S(x)\" true for value \"x\" ?*\r\nThat is indeed the predicate formulation of testing.\r\nThus, every test, if exposed in terms of predicate formulation, and the underlying framework supports \r\nthe predicate formulation, then the TEST code need not to be tested at all!\r\nAll you really would be testing is : whether the formula - or predicate is the correct one.\r\nThe SQL team tests SQL. Users use SQL, and checks that the used SQL is indeed correct.\r\nTake a look around the expressive power of declarative programming : \r\n\r\n\r\n    // for all i > 0 check if l[i] <  l[i-1] --> then the list is NOT sorted\r\n    /*  This is how you do it in nJexl */\r\n    // '_' is the index , '$'' is the implicit loop variable: \r\n    empty ( select{ _ > 0 and $ < $[_-1] }(l) )  // checks if a list is in sorted order    \r\n    // select select items from a list to a new list, \r\n    //empty() checks if something is size 0 or null  \r\n\r\n\r\n## Business Process Automation\r\n\r\nThat begs a bigger question. If the test code can be written in such small pieces of predicate logic,\r\nhow come the actual code is so much more complex and bigger than the test code? \r\nThere is something obviously wrong. The Business Programming front, people are actually making a complete mess of what are actually pretty trivial business processes. \r\n\r\nLesson no 1 learned in any business:  \r\n\r\n>>  Neither bomb, not grenade, nor knife but Only gray cells reign supreme.\r\n\r\nBusiness logic should reside outside code. This is a lesson tried and tested and taught by SAP.\r\n\r\nLesson no 2 learned if anyone studied computer science ( not software ) :\r\n\r\n>> No Business Process is beyond Turing Complete, never will be. So preaching complexity does not help. \r\n   Objective should be *to reduce complexity*,  not to add more into it.\r\n\r\nOver dependence on Java is the root cause in here, which is a terrible choice at business programming (in fact any decent programming),  the verbosity makes it a killer on the loose. Python can do things in 10 lines what Java can do in 100. Scala is a good language and utmost geeky - impractical for business user and use. Python can not talk to Java business objects (Jython does not count, really), \r\nand then Python is not a business process automation language or a software testing language.\r\nBut it is a beautiful language never the less.  \r\n\r\n>> Git was developed in 14 Days. Old Rome was not. Git exists as of now, while Old Rome does not.\r\n\r\nTesting and Business Programming should be less talk, more work. \r\nIf the work takes more than 14 days, you have a talent problem.\r\n\r\nWho tests the test code? Who watches the watchers? \r\nHow business code can ever be *tested* ? Pure theory says never. \r\n\r\n## Business IS NOT Technology\r\n\r\nI remember what people told me about XP when I was working on Windows 7. \r\n*World SIMPLY needs XP on drugs*. No fancy stuff, simply XP on drugs. That works.\r\nBusiness runs in EXCEL. \r\nThus, a language, which is a de-facto EXCEL on the drugs (with data in back-end) solves every business need. \r\n\r\nWhat we clearly do not need is  : [Enterprisification](http://projects.haykranen.nl/java/), albeit world runs on it.\r\nReal engineering is about taking complex ideas, and making them simply usable and reusable to customer.\r\n\r\n## Philosophy\r\n\r\nThus nJexl is a language with it's full focus on *Business Process Automation and Software Testing & Validation*,\r\nnot on commercial fads. This has one singular focus in mind : brevity. It also says *Optmize*.\r\nWhat can be done with 1 people, in 10 days, get it done in 1 day by one guy.\r\n\r\nThus, following is the philosophy of the Language:\r\n\r\n* Reduce the number of lines of the code;\r\n* In every line, reduce the number of characters; \r\n* To boldly go where no developer has gone before - attaining Nirvana in terms of coding;\r\n    - get out of the cycle of bugs and fixes by writing scientific code ( see  [Minimum Description length](http://en.wikipedia.org/wiki/Minimum_description_length) ).\r\n\r\n\r\n## For the Users\r\n\r\nThe WIKI page showcases syntax and power of NJEXL. \r\nThis is a language, like SAP's ABAP to ensure anyone can write effective business code, with a little bit of training. \r\nYes, connect to DB get Business Data and manipulate them, like you do in excel. It is better than ABAP.\r\nYES. ANYONE can do it. That is the motto. It should just work. \r\n\r\nIt is wrong believe that *writing more code makes one superior*. \r\nNo, the opposite is what great developers think. From [Knuth](http://en.wikipedia.org/wiki/Donald_Knuth) \r\nto [Russhinovich](http://en.wikipedia.org/wiki/Mark_Russinovich), everyone agrees there.\r\nThus, the aim is to understand : *any code is faulty code!* . \r\nThus, *less code written is less bugs added*.\r\nThat is *the* motto of nJexl. Reduce the coding effort to such a minimum that nothing extra remains.\r\nMake things simple but not simpler as Einstein have said.\r\n\r\n\r\n## Final Words \r\n\r\nThe language is (unfortunately) written in Java, and mostly bears no resemblance with it's parent, \r\nsome occasional use Java DNA can be seen when we use imported Java Objects and fields. \r\n\r\nWhy not C/C++? Lack of time. This was entirely written\r\nwhen at home, holidaying ( no, a real Engineer never goes in a Holiday, \r\nask Donald Knuth about [his honeymoon](http://www-cs-faculty.stanford.edu/~uno/cl.html) ), \r\nand after office at home, 7p.m to 2a.m in the nights one can check the statistics of the check-ins.\r\n\r\nI wrote this so that I, personally can use a language that makes sense to ME \r\nand I can use it for my own daily work - automation validation. \r\nLet me know what you think of the style of the language. \r\nLive long, and Prosper.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}